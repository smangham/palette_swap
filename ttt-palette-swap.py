#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from typing import List

import gi
gi.require_version('Gimp', '3.0')
from gi.repository import Gimp
gi.require_version('GimpUi', '3.0')
from gi.repository import GimpUi
from gi.repository import GObject
from gi.repository import GLib

# --- DEBUG ---
# import debugpy
# import importlib
# import inspect
# import os
# currentframe = os.path.dirname(inspect.getfile(inspect.currentframe()))
# sys.path.append(currentframe)
# sys.stderr = open(os.path.join(currentframe, "errors.txt"), 'w', buffering=1)
# sys.stdout = open(os.path.join(currentframe, "log.txt"), 'w', buffering=1)
# -------------

import palette_swap
import palette_swap.palette_swap_linear
import palette_swap.palette_swap_simple
import palette_swap.palette_to_layer


# I really don't understand why you can't register two plugin objects?
# This whole plugin setup is very bizarre.

class PaletteSwapLinearMetaPlugin:
    """
    Swaps the current layer from a source palette to a target palette
    """
    name: str = 'ttt-palette-swap-linear'
    menu_label: str = "Swap from old to new palette..."
    menu_path: str = "<Image>/Filters/Map/Palette Swap"
    documentation: str = "Maps the colours from 1-pixel 'old' palette layer to an equivalent 'new' layer,\nthen replaces all the 'old' colours in the current layer with the corresponding 'new' colours."
    dialog_fill: List[str] = [
        'layer-palette-old',
        'layer-palette-new',
    ]

    @classmethod
    def arguments(
            cls: 'PaletteSwapLinearMetaPlugin',
            procedure: Gimp.ImageProcedure
    ):
        """
        Adds arguments specific to this meta-plugin.

        :param cls: This class.
        :param procedure: The procedure to add arguments to.
        """
        procedure.add_layer_argument(
            name='layer-palette-old',
            nick="Old Palette Layer",
            blurb="1-pixel high layer containing colours to be replaced.",
            none_ok=False,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_layer_argument(
            name='layer-palette-new',
            nick="New Palette Layer",
            blurb="1-pixel high layer containing colours to replace them with.",
            none_ok=False,
            flags=GObject.ParamFlags.READWRITE
        )

    @classmethod
    def run(
            cls, procedure, run_mode, image, drawables, config, run_data
    ):
        """
        The method called when the menu shortcut is run.

        :param cls: This class.
        :param procedure: The procedure being called.
        :param run_mode: Whether it's interactive or not.
        :param image: The current image.
        :param drawables: ...not used this?
        :param config: The config values for the procedure.
        :param run_data: ...not used this?
        :return: The return values generated by the procedure.
        """
        # debugpy.wait_for_client()
        # importlib.reload(palette_swap)
        # importlib.reload(palette_swap.palette_swap_linear)

        if run_mode == Gimp.RunMode.INTERACTIVE:
            # print("Starting UI...")
            gi.require_version('Gtk', '3.0')

            GimpUi.init(cls.name)
            dialog = GimpUi.ProcedureDialog.new(procedure, config, cls.menu_label)
            dialog.get_label(
                f'{cls.name}-docs',
                cls.documentation,
                False,
                False,
            )
            dialog.fill([f'{cls.name}-docs']+cls.dialog_fill)
            if not dialog.run():
                return procedure.new_return_values(
                    Gimp.PDBStatusType.CANCEL, GLib.Error()
                )

        layer_palette_old: Gimp.Layer = config.get_property('layer-palette-old')
        layer_palette_new: Gimp.Layer = config.get_property('layer-palette-new')

        invalid_layers: bool = False
        if layer_palette_new.get_height() != 1:
            Gimp.message(f"{layer_palette_new.get_name()} is not 1-pixel high!")
            invalid_layers = True

        if layer_palette_old.get_height() != 1:
            Gimp.message(f"{layer_palette_old.get_name()} is not 1-pixel high!")
            invalid_layers = True

        if invalid_layers:
            return procedure.new_return_values(
                Gimp.PDBStatusType.CALLING_ERROR, GLib.Error()
            )

        # print("Running swap...")
        try:
            palette_swap.palette_swap_linear.palette_swap_linear(
                image,
                layer_target=image.get_selected_layers()[0],
                layer_palette_old=layer_palette_old,
                layer_palette_new=layer_palette_new,
            )
        except Exception as e:
            Gimp.message(f"{e}")
            return procedure.new_return_values(
                Gimp.PDBStatusType.EXECUTION_ERROR, GLib.Error()
            )
        # print("Done!")
        return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())


class PaletteSwapSimpleMetaPlugin:
    """
    Maps the current layer to the palette auto-detected from another layer.
    """
    name: str = 'ttt-palette-swap-simple'
    menu_label: str = "Swap to sample layer's palette..."
    menu_path: str = "<Image>/Filters/Map/Palette Swap"
    documentation: str = "Ranks colours in the current layer by brightness,\nranks colours in the sample layer by brightness,\nthen replaces colours colours in the current layer with their equivalent rank in the sample."
    dialog_fill: List[str] = [
        'layer-sample',
        'count-threshold',
        'include-transparent',
        'light-first',
    ]

    @classmethod
    def arguments(
            cls: 'PaletteSwapSimpleMetaPlugin',
            procedure: Gimp.ImageProcedure
    ):
        """
        Adds arguments specific to this meta-plugin.

        :param cls: This class.
        :param procedure: The procedure to add arguments to.
        """
        procedure.add_layer_argument(
            name="layer-sample",
            nick="Sample Layer",
            blurb="Layer to sample colours from.",
            none_ok=False,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_boolean_argument(
            name="include-transparent",
            nick="Sample transparent pixels",
            blurb="Whether or not to sample colours from transparent pixels.",
            value=True,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_int_argument(
            name="count-threshold",
            nick="Pixel count threshold",
            blurb="Ignore colours with less than this many pixels. May solve problems with rogue wrong-coloured pixels messing up palette detection.",
            min=0, max=GLib.MAXINT, value=5,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_boolean_argument(
            "light-first",
            "Map from lightest pixels down",
            "Go from the lightest to darkest instead. No effect if both have the same number of colours.",
            value=False,
            flags=GObject.ParamFlags.READWRITE
        )

    @classmethod
    def run(
            cls, procedure, run_mode, image, drawables, config, run_data
    ):
        """
        The method called when the menu shortcut is run.

        :param cls: This class.
        :param procedure: The procedure being called.
        :param run_mode: Whether it's interactive or not.
        :param image: The current image.
        :param drawables: ...not used this?
        :param config: The config values for the procedure.
        :param run_data: ...not used this?
        :return: The return values generated by the procedure.
        """
        # debugpy.wait_for_client()
        # importlib.reload(palette_swap)
        # importlib.reload(palette_swap.palette_to_layer)

        if run_mode == Gimp.RunMode.INTERACTIVE:
            # print("Starting UI...")
            gi.require_version('Gtk', '3.0')

            GimpUi.init(cls.name)
            dialog = GimpUi.ProcedureDialog.new(procedure, config, cls.menu_label)
            dialog.get_label(
                f'{cls.name}-docs',
                cls.documentation,
                False,
                False,
            )
            dialog.fill([f'{cls.name}-docs']+cls.dialog_fill)
            if not dialog.run():
                return procedure.new_return_values(
                    Gimp.PDBStatusType.CANCEL, GLib.Error()
                )


        # print("Running swap...")
        try:
            palette_swap.palette_swap_simple.palette_swap_simple(
                image,
                layer_target=image.get_selected_layers()[0],
                layer_sample=config.get_property("layer-sample"),
                include_transparent=config.get_property("include-transparent"),
                light_first=config.get_property("light-first"),
                count_threshold=config.get_property("count-threshold")
            )
        except Exception as e:
            Gimp.message(f"{e}")
            return procedure.new_return_values(
                Gimp.PDBStatusType.EXECUTION_ERROR, GLib.Error()
            )

        # print("Done!")
        return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())


class PaletteToLayerMetaPlugin:
    """
    Creates a 1-pixel high 'palette' layer from the current layer.
    """
    name: str = 'ttt-palette-to-layer'
    menu_label: str = "Create layer from palette..."
    menu_path: str = "<Image>/Filters/Map/Palette Swap"
    documentation: str = "Given a layer, creates a 1-pixel high layer that contains the colours within it, sorted by brightness."
    dialog_fill: List[str] = [
        'count-threshold',
        'include-transparent',
        'layer-name',
    ]

    @classmethod
    def arguments(
            cls: 'PaletteToLayerMetaPlugin',
            procedure: Gimp.ImageProcedure
    ):
        """
        Adds arguments specific to this meta-plugin.

        :param cls: This class.
        :param procedure: The procedure to add arguments to.
        """
        procedure.add_boolean_argument(
            name="include-transparent",
            nick="Sample transparent pixels",
            blurb="Whether or not to sample colours from transparent pixels.",
            value=True,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_int_argument(
            name="count-threshold",
            nick="Pixel count threshold",
            blurb="Ignore colours with less than this many pixels. May solve problems with rogue wrong-coloured pixels messing up palette detection.",
            min=0, max=GLib.MAXINT, value=5,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_string_argument(
            name="layer-name",
            nick="Palette Layer Name",
            blurb="Name of the layer to create.",
            value="Palette",
            flags=GObject.ParamFlags.READWRITE,
        )

    @classmethod
    def run(
            cls, procedure, run_mode, image, drawables, config, run_data
    ):
        """
        The method called when the menu shortcut is run.

        :param cls: This class.
        :param procedure: The procedure being called.
        :param run_mode: Whether it's interactive or not.
        :param image: The current image.
        :param drawables: ...not used this?
        :param config: The config values for the procedure.
        :param run_data: ...not used this?
        :return: The return values generated by the procedure.
        """
        # debugpy.wait_for_client()
        # importlib.reload(palette_swap)
        # importlib.reload(palette_swap.palette_to_layer)

        if run_mode == Gimp.RunMode.INTERACTIVE:
            # print("Starting UI...")
            gi.require_version('Gtk', '3.0')

            GimpUi.init(cls.name)
            dialog = GimpUi.ProcedureDialog.new(
                procedure, config, cls.menu_label
            )
            dialog.get_label(
                f'{cls.name}-docs',
                cls.documentation,
                False,
                False,
            )
            dialog.fill([f'{cls.name}-docs']+cls.dialog_fill)

            if not dialog.run():
                return procedure.new_return_values(
                    Gimp.PDBStatusType.CANCEL, GLib.Error()
                )

        # print("Running swap...")
        try:
            palette_swap.palette_to_layer.palette_to_layer(
                image,
                layer_sample=image.get_selected_layers()[0],
                include_transparent=config.get_property("include-transparent"),
                count_threshold=config.get_property("count-threshold"),
                layer_name=config.get_property("layer-name"),
            )
        except Exception as e:
            Gimp.message(f"{e}")
            return procedure.new_return_values(
                Gimp.PDBStatusType.EXECUTION_ERROR, GLib.Error()
            )

        # print("Done!")
        # do what you want to do, then, in case of success, return:
        return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())


PROCEDURES: dict[str, object] = {
    'ttt-palette-swap-simple': PaletteSwapSimpleMetaPlugin,
    'ttt-palette-swap-linear': PaletteSwapLinearMetaPlugin,
    'ttt-palette-to-layer':PaletteToLayerMetaPlugin,
}


class PaletteSwapPlugin(Gimp.PlugIn):
    def do_query_procedures(self) -> List[str]:
        """List the procedures in the plugin"""
        return list(PROCEDURES.keys())

    def do_set_i18n (self, name: str) -> bool:
        """No translation for this plugin"""
        return False

    def do_create_procedure(self, name: str) -> Gimp.ImageProcedure:
        """
        Register each procedure.

        Does the 'standard' arguments, documentation, e.t.c.,
        then hands off to the metaplugin.

        :param name: The procedure name, from `do_query_procedures`.
        :return: Each individual procedure.
        """
        # print(f"Creating procedure {name}")
        procedure = Gimp.ImageProcedure.new(
            self,
            name,
            Gimp.PDBProcType.PLUGIN,
            PROCEDURES[name].run,
            None,
        )
        procedure.set_image_types("RGBA")
        procedure.set_menu_label(PROCEDURES[name].menu_label)
        procedure.add_menu_path(PROCEDURES[name].menu_path)
        procedure.set_documentation(
            PROCEDURES[name].documentation,
            PROCEDURES[name].documentation,
            name
        )
        procedure.set_attribution(
            "Sam Mangham", "Sam Mangham", "2023"
        )
        # print(f"Adding arguments")
        PROCEDURES[name].arguments(procedure)
        # print(f"Procedure finished")
        return procedure


Gimp.main(PaletteSwapPlugin.__gtype__, sys.argv)
